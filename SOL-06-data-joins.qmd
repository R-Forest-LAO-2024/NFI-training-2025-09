---
title: "Workshop on Data analysis with R for Lao PDRâ€™s fourth National Forest Inventory cycle"
subtitle: "Session 06: data joins"
date: "01-05 Sep 2025"
number-sections: true
toc: true
toc-depth: 2
highlight-style: github
theme: 
  light: flatly
  dark: darkly
format: 
  html: 
    toc-location: left
    embed-resources: true
  docx:
    reference-doc: custom-reference-doc.docx
  pdf: 
    documentclass: scrartcl
    papersize: A4
    colorlinks: true
editor: visual
---

# Goals {.unnumbered}

1.  Assign LCS number to trees

2.  Join land cover and Chave E to trees

# Setup {.unnumbered}

We load libraries and run the code for loading data in the solution script 05 to have our setup ready for data joins

```{r}
#| label: setup
#| output: false
 
## Useful when sourcing script from Quarto doc.
if (!require(here)) install.packages("here"); library(here)

source(here("R/00-load-packages.R"))
source(here("R/SOL-05-data-preparation.R"))
```

<!-- Section 1 -->

# Assign LCS number to trees

Since the Land Cover Sections (LCS) are a mix of center square and outside disc portions, we need both tree position as distance $d$ and azimuth $az$ and as coordinates $(x, y)$.

See the classroom presentation: "main calculations" for explanations on converting distance $d$ and angle $\theta$ to coordinates $(x, y)$ for the subplot center, and converting distance $d$ and azimuth $az$ to coordinates $(x, y)$.

The R implementation is as follows:

```{r}
#| label: tree-coords

tree <- tree |> 
  mutate( 
    tree_x = cos((90 - tree_azimuth) * pi/180) * tree_distance, 
    tree_y = sin((90 - tree_azimuth) * pi/180) * tree_distance, 
    )

```

Once we have tree coordinates, we can assign LCS with `case_when()`, identifying trees in the center square first (with their coordinates), then the outer disc portion based on azimuth:

-   To be inside the center square, trees must have their coordinates $(x, y)$ both between -6 and 6 meters, or their absolute value smaller or equal to 6: $-6 \le x \le 6 = |x| \le 6$

-   To be in one of the outer disc portion, trees must not be in the center square and be respectively positioned between NW and NE lines, NE and SE, SE and SW or SW and NW for the north, east, south and west disc portions. These lines' azimuth are 315, 45, 135, 215 degrees respectively for NW, NE, SE and SW lines.

R implementation:

```{r}
#| label: tree-lcs

tree <- tree |>
  mutate(
    lcs_no = case_when(
      abs(tree_x) <= 6 & abs(tree_y) <= 6     ~ 1,
      tree_azimuth > 315 | tree_azimuth <=45  ~ 2,
      tree_azimuth >  45 & tree_azimuth <=135 ~ 3,
      tree_azimuth > 135 & tree_azimuth <=225 ~ 4,
      tree_azimuth > 225 & tree_azimuth <=315 ~ 5,
      TRUE ~ NA_integer_
    )
  )

```

We can now check if the code implementation worked with a visual check in @exr-01.

:::: {.callout-warning appearance="simple"}
<!-- EX-01 -->

::: {#exr-01}
## Figure of tree locations

\linebreak

Instructions:

-   Filter the tree data for subplot '631C'

-   Make a base figure with `geom_point()`

-   Add subplot boundaries with `geom_path()` and `circ16`

-   Add cardinal lines with `geom_hline(yintercept = 0)` and `geom_vline(xintercept = 0)`

-   Add azimuth to each tree as labels with `geom_label_repel()`.

-   Add `coord_fixed()` to make sure the x and y axis have the same unit length.

Check visually that the trees are positioned correctly based on their azimuth
:::
::::

Write here the answer to @exr-01:

```{r}
#| label: ex-01

## !!! SOL
tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point() + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  geom_label_repel(aes(label = tree_azimuth)) + 
  coord_fixed() 
## !!!
```

<!-- Section 2-->

# Join tables

<!-- Section 2.1 -->

## Prepare tables to join

We want to join 2 tables to the tree data:

-   Chave et al. 2014 environment factor $E$ from the table `anci$plot_E`,

-   Land cover code from the table `lcs`,

Sometimes we don't want all the columns from a tables to be passed on to `tree`. In this case we create a temporary tables with only the **key(s)** = the matching column(s) between two tables to join, and the information to pass.

For example, we don't want `lcs_name` from `lcs` to go to trees, we already have `lcs_no` as key between the two tables. We can either remove the undesired column or keep all other columns. In this case, removing is faster, but for sustainability, it is preferable to write the columns you want to keep so that when you re-open this document in a few weeks you see directly what is kept.

```{r}
#| label: prepa-lcs

tmp_lcs <- lcs |> select(-lcs_name)

## Same but preferable:
tmp_lcs <- lcs |> select(plot_no, subplot_no, lcs_no, lc_no, lc_code)
```

<!-- Section 2.2 -->

## Make the joins

### With changing object

We join LCS (`tmp_lcs`) with the `tree` table using their common keys. In this case there are three keys: `plot_no`, `subplot_no` and `lcs_no`.

```{r}
#| label: join-change

tree_join <- tree |> 
  left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no))

```

It is recommended to change object name when using join to avoid undesired suffixes. Undesired suffixes happen when we join the same tables twice or more by mistake. The second time we join two tables, since the new tables are already in the joined table, they will be passed again but this time with suffixes `.x` and `.y`. Observe undesired suffix in the @exr-02.

:::: {.callout-warning appearance="simple"}
<!-- EX-02 -->

::: {#exr-02}
## Undesired suffixes

\linebreak

Instructions:

-   Create `tree_err` by joining `tree` and `tmp_lcs`

-   Re-create `tree_err` by joining `tree_err` and `tmp_lcs`

-   Run `names(tree_err)`
:::
::::

Type here the answers to @exr-02:

```{r}
#| label: ex-02

## !!! SOL
tree_err <- tree |> left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no))
tree_err <- tree_err |> left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no)) 
names(tree_err)
## !!!
```

## With keeping the same object name

Often time we don't want to change object names for a join if we have a long sequence of modifications ahead. We can join and keep the same object names, but in this case we have to control the suffixes.

Step-by-step:

1.  Identify the new column passed from the table to join.

2.  Create these columns in the receiving table with NAs using `mutate()`,

3.  Join the tables and add suffixes "\_rm" to the receiving table with NAs and "" to the joined columns,

4.  Remove the columns that end with "\_rm" (since they contains NAs).

```{r}
#| label: join-nochange

## 1. Columns to be passed are lc_no and lc_code
tree <- tree |>
  ## 2. Create these columns with NAs
  mutate(lc_no = NA, lc_code = NA) |> 
  ## 3. join with controlled suffix names
  left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no), suffix = c("_rm", "")) |> 
  ## 4. remove initial columns with NAs
  select(-ends_with("_rm"))

```

Practice 'joins with controlled suffix' to join Chave E at plot level from `anci$plot_E` with the @exr-03.

:::: {.callout-warning appearance="simple"}
<!-- EX-03 -->

::: {#exr-03}
## Join Chave E to the trees table

\linebreak

Instructions:

-   Identify which column from `anci$plot_E` to pass to `tree` and which column is the key

-   from `tree`, create a column with NAs that has the same name as the column from `anci$plot_E` that we want in `tree`

-   Join the 2 tables and control the suffixes

-   Remove the initial column with NAs

After the join, check that there is no NAs in `plot_E` from `tree` with the function `summary().`
:::
::::

Type here answers to @exr-03:

```{r}
#| label: ex-03

## !!! SOL
names(anci$plot_E)

tree <- tree |> 
  mutate(plot_E = NA) |>
  left_join(anci$plot_E, by = join_by(plot_no), suffix = c("_rm", "")) |> 
  select(-ends_with("_rm"))

summary(tree$plot_E) 
## !!!
```

Now that we have land cover information at tree level we can make a figure of tree location with color based on land cover code in @exr-04.

:::: {.callout-warning appearance="simple"}
<!-- EX-04 -->

::: {#exr-04}
## (optional) Figure of tree location with land cover

\linebreak

Instructions:

-   Remake the figure of EX-01 with these differences:

-   Change the color of trees based on lc_code

-   Remove geom_label_repel() to show the azimuths

-   Remove hline and vline

-   Add geom_abline() with intercept = 0 and slope = 1

-   Add geom_abline() with intercept = 0 and slope = -1

-   Check visually that different land cover are in different quadrants
:::
::::

Type here answers to @exr-04:

```{r}
#| label: ex-04

## !!! SOL
tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point(aes(color = lc_code)) + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0, slope = -1) + 
  coord_fixed()
## !!!



```

## (optional) Final graph

We can add the square center LCS with a specific table

```{r}
#| label: full-graph

center_sq <- tibble(x = c(-6, 6, 6, -6, -6), y = c(6, 6, -6, -6, 6))

tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point(aes(color = lc_code)) + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0, slope = -1) + 
  geom_path(data= center_sq, aes(x = x, y = y)) +
  coord_fixed()

```
