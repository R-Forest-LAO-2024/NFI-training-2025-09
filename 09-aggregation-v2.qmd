---
title: "Workshop on Data analysis with R for Lao PDRâ€™s fourth National Forest Inventory cycle"
subtitle: "Session 09: Aggregation"
date: "01-05 Sep 2025"
number-sections: true
toc: true
toc-depth: 2
highlight-style: github
theme: 
  light: flatly
  dark: darkly
format: 
  html: 
    toc-location: left
    embed-resources: true
  docx:
    reference-doc: custom-reference-doc.docx
  pdf: 
    documentclass: scrartcl
    papersize: A4
    colorlinks: true
editor: visual
---

# Setup {.unnumbered}

```{r}
#| label: setup
#| output: false
 
## Useful when sourcing script from Quarto doc.
if (!require(here)) install.packages("here"); library(here)

source(here("R/00-load-packages.R"))
source(here("R/fct-nfi-aggregate3-new.R"))

source(here("R/SOL-05-data-preparation.R"))
source(here("R/SOL-06-data-joins.R"))
source(here("R/SOL-07a-tree-weight.R"))
source(here("R/SOL-07b-tree-basal-area.R"))
source(here("R/SOL-08a-tree-agb.R"))
```

# Session 09: Aggregate tree to forest type AGB

**GOALS:**

1.  Calculate the mean aboveground biomass for all forest types using **plot level** land cover and **systematic sampling**.
2.  Calculate the mean aboveground biomass for all forest types using **ratio estimators** and **2-stages sampling for post-stratification**.
3.  Compare estimates.

<!-- Section 9.1 -->

## AGB with plot level land cover and systematic sampling

**Step-by-step**

1.  Sum tree AGB to subplots.

2.  Make plot majority LC class.

3.  Create plot level AGB based on mean subplot AGB.

4.  Create Forest type AGB as the mean of plot AGB per forest type.

5.  Calculate sampling error.

### Sum tree AGB to subplot

We will use `group_by()` and `summarise()` to bring tree characteristics to the subplot level.

```{r}
#| label: sp-agb

subplot_agb <- tree |>
  group_by(plot_no, subplot_no) |>
  summarise(
    sp_agb = sum(tree_agb_final * tree_weight_spha / 1000),
    sp_ba  = sum(tree_ba * tree_weight_spha),
    sp_dens = sum(tree_weight_spha),
    tree_meas = n()
  )
```

### Load plot level main land cover

Plot level land cover was generated, from the subplots center LC, with the following rules:

1.  For plots with one unique LC, they were directly assigned to plot level.
2.  For plots with multiple land cover, we used the majority LC for the whole plot.
3.  If some plots have equal importance of two land covers, we used to minimum land cover class.

```{r}
#| label: load-plotlc

plot_lc <- read_csv("data/training_plot_lc.csv", show_col_types = FALSE)

```

### Aggregate subplot to plot

We take the mean of subplot variables (except tree measured count).

```{r}
#| label: plot-agb

plot_agb <- subplot_agb |>
  group_by(plot_no) |>
  summarise(
    plot_agb = mean(sp_agb),
    plot_ba = mean(sp_ba),
    plot_dens = mean(sp_dens),
    plot_tree_meas = sum(tree_meas)
  ) |>
  left_join(plot_lc, by = join_by(plot_no))

```

Let's look at plot AGB per land cover in @exr-91.

:::: {.callout-warning appearance="simple"}
<!-- EX 9.1 -->

::: {#exr-91}
## \~ Boxplot of plot AGB

\linebreak

Instructions:

-   Make a boxplot of plot AGB against land cover classes
:::
::::

Type here the answers to @exr-91:

```{r}
#| label: ex-91-code

## Your code here
plot_agb |>
  ggplot(aes(x = plot_lc, y = plot_agb)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.1, size = 0.8)
```

### Aggregate to forest type AGB

Now we can take averages of plot AGB for each forest type. For the uncertainty, we also need **standard deviation** of AGB and the **number of plots**.

```{r}
#| label: ftype-agb

ftype_agb <- plot_agb |>
  group_by(plot_lc) |>
  summarise(
    plot_count = n(),
    total_tree_meas = sum(plot_tree_meas),
    ftype_dens = mean(plot_dens),
    ftype_ba = mean(plot_ba),
    ftype_agb = mean(plot_agb),
    ftype_agb_sd = sd(plot_agb)
  )

```

We can calculate the uncertainty for systematic design with this formula:

$$
U\% = t^{1 - \alpha/2}_{n-1} \times \frac{\sigma}{\sqrt{n}} \times \frac{1}{\mu} \times 100
$$

```{r}
#| label: ftype-agbu

ftype_agb <- ftype_agb |>
  mutate(
    ftype_agb_se = ftype_agb_sd / sqrt(plot_count),
    ftype_agb_me = qt(0.975, plot_count - 1) * ftype_agb_se,
    ftype_agb_U  = ftype_agb_me / ftype_agb * 100,
    ftype_agb_cilower = ftype_agb - ftype_agb_me,
    ftype_agb_ciupper = ftype_agb + ftype_agb_me
  )

```

Make a plot of forest type AGB with sampling uncertainty

```{r}
#| label: ftype-agb-plot

ftype_agb |>
  ggplot(aes(x = plot_lc, y = ftype_agb)) +
  geom_col(aes(fill = plot_lc), col = "black") +
  geom_errorbar(aes(ymin = ftype_agb_cilower, ymax = ftype_agb_ciupper)) +
  theme(legend.position = "none") +
  ylim(0, 600)

```

<!-- Section 9.2 -->

## AGB with ratio estimator and 2-stages sampling for post-stratification

Step-by-step:

1.  Prepare subplot x LCS level table

2.  Use the aggregate function 'nfi_aggregate3()' to get all aggregation levels

3.  Compare results with equal plot statistiscs (table 'ftype')

### Prepare the subplot x LCS table for aggregation

#### Initial data preparation

For the second approach, all subplots must be accounted for, visited or not, accessible or not. This table has been prepared and can be loaded into the ancillary data list `anci`.

```{r}
#| label: load-ph2

anci$ph2 <- read_csv("data/training_anci_phase2.csv", show_col_types = F)

ph2_subplot <- anci$ph2

# format(nrow(anci$ph2) / 20, big.mark = ",")
```

We can observe that `anci$ph2` contains `r format(nrow(anci$ph2) / 20, big.mark = ",")` *(1,067)* plots, as initially planned in the 12 x 18 km grid.

To generate this table, instead of starting from tree aggregates or from the subplot table, we start from the vector of planned Phase 2 plots and we recreate all combinations of subplot x LCS with `expand_grid()` .

```{r}
#| label: recreate-ph2

vec_ph2 <- anci$ph1 |> 
  filter(!is.na(plot_id)) |>
  pull(plot_id) |>
  sort()

test_ph2 <- expand_grid(
  plot_id = vec_ph2,
  subplot_no = c("A", "B", "C", "D"),
  lcs_no = 1:5
) |>
  mutate(subplot_id = paste0(subplot_no, lcs_no))

```

We can check that this table is identical to `anci$ph2` with `all.equal()`:

```{r}
tmp_ph2 <- anci$ph2 |> select(plot_id, subplot_no, lcs_no, subplot_id)

all.equal(tmp_ph2, test_ph2)
```

We then need to add accessibility from subplot and subpopulation and strata from phase 1 data with `left_join()` in @exr-92.

:::: {.callout-warning appearance="simple"}
<!-- EX 9.2 -->

::: {#exr-92}
## \~ (optional) Join core info to phase 2 table

\linebreak

Instructions:

-   Prepare 'tmp_sp' a table containing `plot_no`, `subplot_no` and `subplot_access` from the subplot table and rename `plot_no` into `plot_id`.

-   Prepare 'tmp_ph1' a table containing `plot_id`, `subpop`, `stratum` , `ph1_prov_no` and `ph1_prov_name` from the table `anci$ph1` and rename `ph1_prov_no` into `prov_no` and `ph1_prov_name` into `prov_name`

-   Join these 2 tables to `ph2_subplot` with suffix control method.
:::
::::

Type here answers to @exr-92:

```{r}
#| label: ex-92-code

## Your code here
## !!! SOL
tmp_sp <- subplot |> select(plot_id = plot_no, subplot_no, subplot_access)

tmp_ph1 <- anci$ph1 |>
  filter(!is.na(plot_id)) |>
  select(plot_id, subpop, stratum, prov_no = ph1_prov_no, prov_name = ph1_prov_name)

ph2_subplot <- ph2_subplot |>
  mutate(
    subplot_access = NA,
    subpop = NA, 
    stratum = NA,
    prov_no = NA,
    prov_name = NA
  ) |>
  left_join(tmp_ph1, by = join_by(plot_id), suffix = c("_rm", "")) |>
  left_join(tmp_sp, by = join_by(plot_id, subplot_no), suffix = c("_rm", "")) |>
  select(-ends_with("_rm"))
## !!!
```

In the final preparation phase 2 subplot table, correction for shifted plots was implemented before end.

#### **Re-coding accessibility**

Accessibility plays an important role in the final estimates. Since not all the initial 1,067 plots were visited. There is missing information on many non-forest plots and some forest plots. To simplify the calculations, it was considered that all non-visited forest plots would be considered as non-accessible but all non-visited non-forest plots would be considered as accessible with biomass 0.

This is important to keep in mind in case biomass of trees outside forest becomes relevant for future NFI cycles.

```{r}
#| label: sp-access

ph2_subplot <- ph2_subplot |>
  mutate(
    access = case_when(
      plot_id <= 636 & subplot_access == "accessible" ~ TRUE,
      plot_id <= 636 & subplot_access != "accessible" ~ FALSE,
      plot_id <= 636 & is.na(subplot_access) ~ FALSE,
      stratum %in% 1:3 ~ FALSE,
      stratum == 4 ~ TRUE,
      TRUE ~ NA
    )
  )

```

#### Subplot largest area

For aggregation with ratio estimator we need to keep track of the areas where trees are measured. Since we have a tree weight for small trees, we are only interested in the larger area: 12 m side square of a quarter of the difference between the 16m radius circle and the 12m side square.

```{r}
#| label: sp-area

ph2_subplot <- ph2_subplot |>
  mutate(
    sp_area = if_else(lcs_no == 1, 12^2, (pi*16^2 - 12^2)/4) / 10000
  )

```

#### Aggregate tree to subplot x LCS

We can now aggregate trees to the subplot x LCS level and join with the phase 2 subplot table.

```{r}
#| label: agg-tree

ph2_sp_tree <- tree |>
  select(plot_id = plot_no, subplot_no, lcs_no, tree_no, tree_stem_no, tree_dbh, tree_weight, tree_ba, tree_agb_final) |>
  mutate(
    subplot_id = paste0(subplot_no, lcs_no)
  ) |>
  group_by(plot_id, subplot_id) |>
  summarise(
    dens = sum(tree_weight),
    ba   = sum(tree_ba * tree_weight),
    agb  = sum(tree_agb_final * tree_weight) / 1000, ## Convert kg to tons
    .groups= "drop"
  )

```

```{r}
#| label: join-tree

ph2_subplot <- ph2_subplot |>
  mutate(
    dens = NA,
    ba = NA,
    agb = NA
  ) |>
  left_join(ph2_sp_tree, by = join_by(plot_id, subplot_id), suffix = c("_rm", "")) |>
  select(-ends_with("_rm")) |>
  mutate(
    dens = if_else(!is.na(dens), n_tree, 0),
    ba   = if_else(!is.na(ba), ba, 0),
    agb  = if_else(!is.na(agb), agb, 0)
  )

```

### Run the aggregation function

The aggregation function 3, for 2-stages sampling with ratio estimator, takes phase 1 and phase 2 data as input as well as the attributes $y$ and $x$ for the ratio. $y$ can change based on what attribute we want to aggregate, while $x$ is always the minimum measured area.

Let's see an example with tree density and no subpopulation.

```{r}
#| label: res3_dens

ph2_data <- ph2_subplot |> mutate(subpop = 1)

res3_dens <- nfi_aggregate3(
  .ph1_df = anci$ph1, 
  .ph2_sp = ph2_data, 
  .class_d = lc_no, 
  .attr_y = dens, 
  .attr_x = sp_area, 
  .aoi_area = 23680000
    )

```

The function output is a list with different levels of data aggregation.

Practice now the function `nfi-aggregate3()` to get basal area and aboveground biomass in @exr-93.

:::: {.callout-warning appearance="simple"}
<!-- Ex 9.3 -->

::: {#exr-93}
## \~ Aggregate basal area and AGB

\linebreak

Instructions:

-   Create `res3_ba` as the output of the aggregation function with basal area as `.attr_y` .

-   Create `res3_agb` as the output of the aggregation function with basal area as `.attr_y` .

-   Make a barplot with AGB per ha against land cover with their error bars, for natural forest only.
:::
::::

Type here answers to @exr-93:

```{r}
#| label: ex-93-code

## !!! SOL
res3_ba <- nfi_aggregate3(
  .ph1_df = anci$ph1, 
  .ph2_sp = ph2_data, 
  .class_d = lc_no, 
  .attr_y = ba, 
  .attr_x = sp_area, 
  .aoi_area = 23680000
  )

res3_agb <- nfi_aggregate3(
  .ph1_df = anci$ph1, 
  .ph2_sp = ph2_data, 
  .class_d = lc_no, 
  .attr_y = dens, 
  .attr_x = sp_area, 
  .aoi_area = 23680000
    )

res3_agb$totals_short |>
  filter(lc_no <= 19) |>
  ggplot(aes(x = lc_no, y = Rd)) +
  geom_col(aes(fill = lc_no), col = "black") +
  theme(legend.position = "none") +
  geom_errorbar(aes(ymin = Rd - Rd*Rd_mep/100, ymax = Rd + Rd*Rd_mep/100))
```

<!-- Section 9.3 -->

## Compare AGB estimates from the 2 aggregation methods
