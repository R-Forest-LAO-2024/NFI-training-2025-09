---
title: "Workshop on Data analysis with R for Lao PDR’s fourth National Forest Inventory cycle"
subtitle: "Session 06: data joins"
date: "01-05 Sep 2025"
number-sections: true
toc: true
toc-depth: 2
#highlight-style: github
theme: 
  light: flatly
  dark: darkly
format: 
  html: 
    toc-location: left
    embed-resources: true
  docx:
    reference-doc: custom-reference-doc.docx
  pdf: 
    documentclass: scrartcl
    papersize: A4
    colorlinks: true
editor: visual
---

# Context {.unnumbered}

This training contains all the code presented and the exercises with solutions for the "**Training workshop on Data analysis with R for Lao PDR’s fourth National Forest Inventory cycle**", held in FIPD office, Vientiane, Lao PDR, from 1st to 5th September 2025.

The training objective was to:

1.  Continue build capacities of FIPD in forest data analysis with R and Rstudio.
2.  Present the code base used for analyzing the 4th National Forest Inventory of Lao PDR, implemented in 2024 and 2025.
3.  Explore opportunities to build a R community with research institutions and the civil society to help each other build analytical skills and deal with complex data analysis in the forest, ecology and environment sectors.

This report compiles the main slides of the presentation, all the code presented during the training, with the exerices and the solutions.

# Initial Setup {.unnumbered}

Before going to loading data and perform the analysis, we need to prepare the environment by loading packages and setting a few options. Here we don't load directly packages, but we source a script that load them.

```{r}
#| label: setup
#| output: false
 
## Useful when sourcing script from Quarto doc.
if (!require(here)) install.packages("here"); library(here)

source(here("R/00-load-packages.R"))
```

# Session 01: Objectives

TBD

<!-- MAIN SECTION BREAK -->

{{< pagebreak >}}

<!-- MAIN SECTION BREAK -->

# Session 02: Updated calculation chain for the NFI cycle 4 carbon analysis

TBD

<!-- MAIN SECTION BREAK -->

{{< pagebreak >}}

<!-- MAIN SECTION BREAK -->

# Session 03: Discussion and remarks on the updated calculations

TBD

<!-- MAIN SECTION BREAK -->

{{< pagebreak >}}

<!-- MAIN SECTION BREAK -->

# Session 04: Refresher on R for forest data analysis

TBD

<!-- MAIN SECTION BREAK -->

{{< pagebreak >}}

<!-- MAIN SECTION BREAK -->

# Session 05: data preparation

**Goals**

1.  Load initial tables and visualize core data

2.  Correct errors in subplot table (duplicates in subplot_id)

<!-- Section 5.1 -->

## Load harmonized tables and ancillary data

<!-- Section 5.1.1 -->

### Load subplot, lcs, tree tables from NFI

We can read tables or CSV files from the computer with the function `read_csv()`. We can store the initial table in objects with the suffix '\_init' to keep the initial version in the environment.

Example: read the table 'training_subplot.csv' from the computer into the object `subplot_init`:

```{r}
subplot_init <- read_csv("data/training_subplot.csv", show_col_types = FALSE)
```

Load the tables 'training_tree.csv' and 'training_lcs.csv' in the @exr-51.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 5.1 -->

::: {#exr-51}
## \~ Load 'training_tree.csv' and 'training_lcs.csv' tables

-   Load the table 'training_lcs.csv' in the R objects 'lcs_init'.
-   Load the table 'training_tree.csv' in the R objects 'tree_init'.
:::
::::

Answer to @exr-51:

```{r}
#| label: ex-51-code

## !!! Solution
lcs_init <- read_csv("data/training_lcs.csv", show_col_types = FALSE)
tree_init <- read_csv("data/training_tree.csv", show_col_types = FALSE)
```

<!-- section 5.1.2 -->

## Load ancillary data

**Ancillary data are not collected in the field but useful for the analysis of field data.**

In the training we use plot level environment factor (E) from Chave et al. 2014 and the NFI Phase 1 plot data. Ancillary data are loaded into a list to keep the environment tidy.

```{r}
anci <- list()
anci$ph1    <- read_csv("data/training_anci_phase1.csv", show_col_types = FALSE)
anci$plot_E <- read_csv("data/training_anci_plotE.csv", show_col_types = FALSE)
```

<!-- Section 5.1.3 -->

## Visualize tree locations

We visualize tree locations from the `tree_init` table with `ggplot()` and `geom_point()` to see if any potential error.

Step-by-step for one subplot:

-   Define `circ16` as tibble of 100 rows to draw a circular plot in ggplot, based on a radius and an angle "theta" $\theta$ in radian.

-   Draw a ggplot with trees from the table `tree_init` in plot 631 and subplot "C", using `filter()`,

-   Use `tree_x` and `tree_y` to show trees based on their location from the subplot center,

-   Add plot boundary with `circ16`.

```{r}
circ16 <- tibble(
  theta = seq(0, 2*pi, length = 100),
  x = 16 * cos(theta),
  y = 16 * sin(theta)
)

tree_init |>
  filter(plot_no == 631, subplot_no == "C") |>
  ggplot(aes(x = tree_x, y = tree_y)) +
  geom_point() +
  geom_path(data = circ16, aes(x = x, y = y)) +
  coord_fixed()
```

Adapt the previous code to make a tree location map for the subplot '1A' and add different colors based on tree DBH size in @exr-52.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 5.2 -->

::: {#exr-52}
## \~ Make a tree location figure

-   create the table `circ08` similar to `circ16` but for a 8m radius circle.

-   Filter within `tree` the trees from subplot '1A' with `filter()`.

-   Use `mutate()` and `if_else()` to add a column `tree_dbh_cat` that has value "small" for trees with DBH \< 30 cm and "big" for the other trees.

-   Make the figure of tree location with the 8m and 16m radius circles and change the color of trees based on `tree_dbh_cat`.

-   Use `labs()` to create clean labels in English or Lao.
:::
::::

Answer to @exr-52:

```{r}
#| label: ex-52-code

## !!! Solution
circ08 <- tibble(
  theta = seq(0, 2*pi, length = 100),
  x = 8 * cos(theta),
  y = 8 * sin(theta)
)

tree_init |> 
  filter(plot_no == 1, subplot_no == "A") |>
  mutate(tree_dbh_cat = if_else(tree_dbh < 30, "small", "big")) |>
  ggplot(aes(x = tree_x, y = tree_y)) +
  geom_point(aes(color = tree_dbh_cat)) +
  geom_path(data = circ08, aes(x = x, y = y)) +
  geom_path(data = circ16, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)", color = "DBH cat.")
```

Visualizations can also be used to detect outliers. We use the example of small trees outside the nested subplot circle of 8m radius as guided exercise in @exr-53.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 5.3 -->

::: {#exr-53}
## \~ (Optional) detect outliers on graph  

**Part 1: Find outliers**

-   Make a figure with tree location of all trees smaller than or equal to 30 cm with the 2 circles of 8 and 16 meters.

<!-- -->

-   Use filter() to get all trees with DBH \<= 30 cm.

-   Make the ggplot of tree locations

**Part 2: highlight outliers**

We can highlight outliers by making a specific table for them.

-   Create the table `outliers` containing trees with DBH \<= 30 and distance \> 8. Use `filter()`.

-   Make the same figure as before and add a `geom_point()` with `data = outliers`, `shape = 23` and `size = 4` .

TIP: here we added `alpha = 0.2` to the geometry of the trees. It make tree point semi-transparent and helps to detect potential measurement issues if we would detect patches with few trees.

**Part 3: explanations**

Now are these outliers measurement errors?

-   Make the same graph as this exercise's part 1, but this time with tree DBH \< 30 and [**not**]{.underline} DBH \<= 30.
:::
::::

Type here answers to @exr-53 part1:

```{r}
#| label: ex-53-1

## !!! Solution
tree_init |> 
  filter(tree_dbh <= 30) |>
  ggplot(aes(x = tree_x, y = tree_y)) +
  geom_point(col = "darkred") +
  geom_path(data = circ08, aes(x = x, y = y)) +
  geom_path(data = circ16, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)")
```

Type here answers to @exr-53 part2:

```{r}
#| label: ex-53-2

## !!! Solution
outliers <- tree_init |> filter(tree_dbh <= 30, tree_distance > 8)

tree_init |> 
  filter(tree_dbh <= 30) |>
  ggplot(aes(x = tree_x, y = tree_y)) +
  geom_point(alpha = 0.2) +
  geom_point(data = outliers, col = "red", shape = 23, size = 4) +
  geom_path(data = circ08, aes(x = x, y = y)) +
  geom_path(data = circ16, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)")
```

Type here answers to @exr-53 part3:

```{r}
#| label: ex-53-3

## !!! Solution
tree_init |> 
  filter(tree_dbh < 30) |>
  ggplot(aes(x = tree_x, y = tree_y)) +
  geom_point(col = "darkred") +
  geom_path(data = circ08, aes(x = x, y = y)) +
  geom_path(data = circ16, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)")

```

Conclusion of @exr-53: the trees found outside the small circle were trees with DBH = 30 cm. They were not measurement errors, they were part of the big trees and therefore could be found outside the 8m radius circle.

<!-- Section 5.2 -->

## Find and correct errors

One of the main issue found in the raw data was the entry errors of subplot and tree IDs. It is very important in Database Management Systems (DBMS) to have unique IDs for all tables. In NFI it is particularly important for joining information from one table to the other. For example, land cover information is recorded at subplot level and needs to be passed on to tree level to apply the correct allometric equations. These errors can be detected programatically but often have to be solved manually.

This section introduces how to use `group_by()` and `summarise()` to find duplicates in subplot IDs.

<!-- section 5.2.1 -->

### Identify duplicates in subplot IDs

Here we want to check within subplots if there are duplicates in subplot IDs (`subplot_id`) and plot numbers (`plot_no`) in the `subplot_init` table. The objective is to create a vector of subplot Ids that are duplicated. If there are no duplicate the vector will be of length 0.

step-by-step:

-   Create a vector `vec_dup` and assign it the following code sequence.

-   Group the subplot table by subplot ID with `group_by()` and use `summarise()` to count the number of subplots that have each ID inside a new column `count`. Use the function `n()` to count.

-   Filter all the subplot IDs that have a count bigger than 1 with `filter()`.

-   Pull the subplot IDs.

```{r}
vec_dup <- subplot_init |>
  group_by(subplot_id) |>
  summarise(count = n(), .groups = "drop") |>
  filter(count > 1) |>
  pull(subplot_id)
vec_dup
```

Notice the results as 3 subplots have duplicate `subplot_id`.

Now practice the same code sequence to check if there are duplicates in `plot_no` in the @exr-54. Note that each plot ID should appears 4 times in the subplot table, one for each subplot, so duplicates are when `count > 4`.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 5.4 -->

::: {#exr-54}
## \~ Identify duplicates of plot number

-   Create `vec_dup2` similarly to `vec_dup`, but this time looking for plot_no that have more than 4 subplot IDs, so you will need to group by `plot_no` and filter `count > 4` and pull `plot_no`.

There should be no duplicates of `plot_no`.
:::
::::

Answer to @exr-54:

```{r}
#| label: ex-54-code

## !!! Solution
vec_dup2 <- subplot_init |>
  group_by(plot_no) |>
  summarise(count = n(), .groups = "drop") |>
  filter(count > 4) |>
  pull(plot_no)
vec_dup2
```

There should be no duplicates of `plot_no`.

<!-- Section 5.2.2 -->

### Correct the subplot ID issues

To correct the duplicates in subplot_id, we filter the subplots from one of the duplicated IDs and visually check what is wrong. In case one ID is missing and one is duplicated we can use time stamps to identify which of the duplicates should be renamed.

Then we can use `mutate()` and `case_when()` to apply correction in R.

Step-by-step:

-   Filter the subplots of one plot with duplicates: 631C.
-   Visualize the table (run `View(tt)` or click `tt` in the Environment tab (top-right window in Rstudio).
    -   In the case of '631C' there are 2 subplots C but no B. we can use time stamps to identify that `ONA_index` 109 should actually be for subplot B.
-   Perform the correction using `case_when()` function for subplot_id 631C. At this stage only `ONA_index` is unique so it can be used to correctly identify the subplot to correct.

```{r}
tt <- subplot_init |> filter(plot_no == 631)

# View(tt)

subplot <- subplot_init |>
  mutate(
    subplot_no = case_when(
      subplot_id == "631C" & ONA_index == 109 ~ "B",
      ## ADD more corrections,
      TRUE ~ subplot_no
    )
  )
```

You can now copy/paste the above R chunk and complete the correction for the 2 other subplot IDs with duplicates in @exr-55.

Note: we correct `subplot_no` now, but we will need to remake `subplot_id` once `subplot_no` is correct.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 5.5 -->

::: {#exr-55}
## \~ Correct duplicates in subplot IDs

-   for each remaining duplicate, run the table `tt` with all subplots for the plot with duplicates

-   Visualize `tt` and identify `ONA_index` of the subplot that should be corrected and what is the correct `subplot_no`.

-   Copyu/paste the `subplot <- ...` sequence from above and fill in the `case_when()` with all the correction for the 3 duplicated subplots.
:::
::::

Solution to @exr-55:

```{r}
#| label: ex-55-code

## !!! Solution
subplot <- subplot_init |>
  mutate(
    subplot_no = case_when(
      subplot_id == "631C" & ONA_index == 109 ~ "B",
      subplot_id == "632C" & ONA_index == 113 ~ "B",
      subplot_id == "553D" & ONA_index == 265 ~ "C",
      TRUE ~ subplot_no
    )
  )
```

Now we can recreate `subplot_id` from the corrected `subplot_no`. Since `subplot_id` is a text field, we need to make it consistent for number of characters to ensure correct sorting of the rows. For this purpose we include texts "0" and "00" to make the number of characters consistent.

```{r}
subplot <- subplot |>
  mutate(
    subplot_id = case_when(
      plot_no < 10 ~ paste0("00", plot_no, subplot_no),
      plot_no < 100 ~ paste0("0", plot_no, subplot_no),
      TRUE ~ paste0(plot_no, subplot_no)
    )
  )
```

Now if we re-run the `vec_dup` sequence with `subplot` instead of `subplot_init`, `vec_dup` should be of length 0.

```{r}
vec_dup <- subplot |>
  group_by(subplot_id) |>
  summarise(count = n(), .groups = "drop") |>
  filter(count > 1) |>
  pull(subplot_id)
vec_dup
```

<!-- Section 5.2.3 -->

### Check outliers in tree table

The tree table we can check for outliers in numeric columns with the `summary()` function.

For example with DBH:

```{r}
summary(tree_init$tree_dbh)
```

There are no trees with DBH \< 10 cm or unrealistically big DBH, all good.

We can check for outliers in tree distance and azimuth in @exr-56.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 5.6 -->

::: {#exr-56}
## \~ Check azimuth and distance

-   Check that azimuth is between 0 and 360.

-   Check that distance is between 0 and 16.
:::
::::

Solution to @exr-56:

```{r}
#| label: ex-06

summary(tree_init$tree_azimuth)
summary(tree_init$tree_distance)
```

<!-- Section 5.3 -->

## Assigning clean data to objects

After resolving all errors, save the tables to the entity name without "\_init" suffix. This way we have both the initial and corrected version in the environment. If tehre were no errors the inital tables can be passed directly to the corrected tables:

```{r}
tree <- tree_init
lcs <- lcs_init

```

Finally we can remove the temporary objects that won't be used later.

```{r}
rm(vec_dup, vec_dup2, tt, outliers)
```

**NOTE: use of temporary object list `tmp`.**

In the main analysis the temporary objects are often stored in a list called `tmp`. This avoids cluttering the environment with temporary objects and makes it easy to remove them with `rm(tmp)`.

```{r}
#| eval: false

## Create empty list
tmp <- list()

## Populate the list (example)
tmp$outliers <- tree_init |> filter(tree_dbh <= 30, tree_distance > 8)

## Remove temporary objects
rm(tmp)

```

<!-- MAIN SECTION BREAK -->

{{< pagebreak >}}

<!-- MAIN SECTION BREAK -->

# Session 06: data joins

**Goals:**

1.  Assign LCS number to trees

2.  Join land cover and Chave E to trees

<!-- Section 6.1 -->

## Assign LCS number to trees

Since the Land Cover Sections (LCS) are a mix of center square and outside disc portions, we need both tree position as distance $d$ and azimuth $az$ and as coordinates $(x, y)$.

See the classroom presentation: "main calculations, TIP02" for explanations on converting distance $d$ and angle $\theta$ to coordinates $(x, y)$ for the subplot center, and converting distance $d$ and azimuth $az$ to coordinates $(x, y)$.

![Conversion of distance/azimuth to x, y](img/TIP01.png)

The R implementation is as follows:

```{r}
#| label: tree-coords

tree <- tree |> 
  mutate( 
    tree_x = cos((90 - tree_azimuth) * pi/180) * tree_distance, 
    tree_y = sin((90 - tree_azimuth) * pi/180) * tree_distance, 
    )

```

Once we have tree coordinates, we can assign LCS with `case_when()`, identifying trees in the center square first (with their coordinates), then the outer disc portion based on azimuth:

-   To be inside the **center square**, trees must have their coordinates $(x, y)$ both between -6 and 6 meters, or their absolute value smaller or equal to 6:

    $$
    -6 \le x \le 6 \Leftrightarrow |x| \le 6 \\ -6 \le y \le 6 \Leftrightarrow |y| \le 6
    $$

-   To be in one of the **outer disc portions**, trees must not be in the center square and be respectively positioned between NW and NE lines, NE and SE, SE and SW or SW and NW for the north, east, south and west disc portions. These lines' azimuth are 315, 45, 135, 215 degrees respectively for NW, NE, SE and SW lines.

R implementation:

```{r}
#| label: tree-lcs

tree <- tree |>
  mutate(
    lcs_no = case_when(
      abs(tree_x) <= 6 & abs(tree_y) <= 6     ~ 1,
      tree_azimuth > 315 | tree_azimuth <=45  ~ 2,
      tree_azimuth >  45 & tree_azimuth <=135 ~ 3,
      tree_azimuth > 135 & tree_azimuth <=225 ~ 4,
      tree_azimuth > 225 & tree_azimuth <=315 ~ 5,
      TRUE ~ NA_integer_
    )
  )

```

We can now check if the code implementation worked with a visual check in @exr-61.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 61 -->

::: {#exr-61}
## \~ Figure of tree locations

-   Filter the tree data for subplot '**123B**'.

-   Make a base figure with `geom_point().`

-   Add subplot boundaries with `geom_path()` and `circ16`.

-   **Add cardinal lines with `geom_hline(yintercept = 0)` and `geom_vline(xintercept = 0).`**

-   **Add azimuth to each tree as labels with `geom_label_repel()`**.

-   Add `coord_fixed()` to make sure the x and y axis have the same unit length.

Check visually that the trees are positioned correctly based on their azimuth!
:::
::::

Answer to @exr-61:

```{r}
#| label: ex-61-code

## !!! Solution
tree |>
  filter(plot_no == 123, subplot_no == "B") |>
  ggplot(aes(x = tree_x, y = tree_y)) +
  geom_point(aes(color = as.character(lcs_no))) +
  geom_path(data = circ16, aes(x = x, y = y)) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_text_repel(aes(label = tree_azimuth), min.segment.length = 0) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)", color = "LCS")

```

We can observe that azimuths have been well converted to $(x, y)$ since azimuth labels are in their correct quadrants (0-90, 90-180, 180-270 ad 270-360 degree respectively).

<!-- Section 6.2-->

## Join tables

<!-- Section 6.2.1 -->

### Prepare tables to join

We want to join 2 tables to the tree data:

-   Chave et al. 2014 environment factor $E$ from the table `anci$plot_E`,

-   Land cover code from the table `lcs`,

Sometimes we don't want all the columns from a tables to be passed on to `tree`. In this case we create a temporary tables with only the **key(s)** = the matching column(s) between two tables to join, and the information to pass.

For example, we don't want `lcs_name` from `lcs` to go to trees, we already have `lcs_no` as key between the two tables. We can either remove the undesired column or keep all other columns. In this case, removing is faster, but for sustainability, it is preferable to write the columns you want to keep so that when you re-open this document in a few weeks you see directly what is kept.

```{r}
#| label: prepa-lcs

tmp_lcs <- lcs |> select(-lcs_name)

## Same but preferable:
tmp_lcs <- lcs |> select(plot_no, subplot_no, lcs_no, lc_no, lc_code)
```

<!-- Section 6.2.2 -->

### Make the joins

-   **With changing object**

We join LCS (`tmp_lcs`) with the `tree` table using their common keys. In this case there are three keys: `plot_no`, `subplot_no` and `lcs_no`.

```{r}
#| label: join-change

tree_join <- tree |> 
  left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no))

```

It is recommended to change object name when using join to avoid undesired suffixes. Undesired suffixes happen when we join the same tables twice or more by mistake. The second time we join two tables, since the new tables are already in the joined table, they will be passed again but this time with suffixes `.x` and `.y`. Observe undesired suffix in the @exr-62.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 6.2 -->

::: {#exr-62}
## \~ Undesired suffixes

-   Create `tree_err` by joining `tree` and `tmp_lcs`

-   Re-create `tree_err` by joining `tree_err` and `tmp_lcs`

-   Run `names(tree_err)`
:::
::::

Answers to @exr-62:

```{r}
#| label: ex-62-code

## !!! Solution
tree_err <- tree |> 
  left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no))
tree_err <- tree_err |> 
  left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no))
names(tree_err)
```

-   **With keeping the same object name**

Often time we don't want to change object names for a join if we have a long sequence of modifications ahead. We can join and keep the same object names, but in this case we have to **control the suffixes**.

Step-by-step:

1.  Identify the **new column** passed from the table to join.

2.  **Create these columns in the receiving table** with NAs using `mutate()`,

3.  **Join the tables and add suffixes** "\_rm" to the receiving table with NAs and "" to the joined columns,

4.  **Remove the columns** that end with "\_rm" (since they contains NAs).

```{r}
#| label: join-nochange

## 1. Columns to be passed are 'lc_no' and 'lc_code'
tree <- tree |>
  ## 2. Create these columns with NAs
  mutate(lc_no = NA, lc_code = NA) |> 
  ## 3. join with controlled suffix names
  left_join(tmp_lcs, by = join_by(plot_no, subplot_no, lcs_no), suffix = c("_rm", "")) |> 
  ## 4. remove initial columns with NAs
  select(-ends_with("_rm"))

```

Practice 'joins with controlled suffix' to join Chave E at plot level from `anci$plot_E` with the @exr-63.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 6.3 -->

::: {#exr-63}
## \~ Join Chave E to the trees table

-   Identify which column from `anci$plot_E` to pass to `tree` and which column is the key

-   from `tree`, create a column with NAs that has the same name as the column from `anci$plot_E` that we want in `tree`

-   Join the 2 tables and control the suffixes ( add `suffix = c("_rm", "")` )

-   Remove the initial column with NAs (they have now suffix "\_rm")

After the join, check that there is no NAs in `plot_E` from `tree` with the function `summary().`
:::
::::

Answers to @exr-63:

```{r}
#| label: ex-63-code

## Your code
# names(anci$plot_E)

tree <- tree |>
  mutate(plot_E = NA) |>
  left_join(anci$plot_E, by = join_by(plot_no), suffix = c("_rm", "")) |>
  select(-ends_with("_rm"))

summary(tree$plot_E)
```

Now that we have land cover information at tree level we can make a figure of tree location with color based on land cover code in @exr-64.

:::: {.callout-warning appearance="simple"}
<!-- EX 6.4 -->

::: {#exr-64}
## \~ (optional) Figure of tree location with land cover

-   Remake the figure of @exr-61 with these differences:

-   Change the color of trees based on lc_code

-   Remove geom_label_repel() to stop showing the azimuths

-   Remove hline and vline

-   Add geom_abline() with intercept = 0 and slope = 1

-   Add geom_abline() with intercept = 0 and slope = -1

-   Check visually that different land cover are in different quadrants
:::
::::

Type here answers to @exr-64:

```{r}
#| label: ex-64-code

## !!! Solution
tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point(aes(color = lc_code)) + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0, slope = -1) + 
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)", color = "land cover")
```

Subplot '123B' is split between two land covers, Mixed deciduous (MD) in the land cover sections (LCS) 1, 2 and 5, and agriculture in LCS 3 and 4.

<!-- Section 6.2.3 -->

### (optional) Final graph

We can add the square center LCS with a specific table

```{r}
#| label: full-graph

center_sq <- tibble(x = c(-6, 6, 6, -6, -6), y = c(6, 6, -6, -6, 6))

tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point(aes(color = lc_code)) + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0, slope = -1) + 
  geom_path(data= center_sq, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)", color = "LCS")

```

### Bonus: Tree DBH true to size on figures with the `ggforce` package.

Graphs with `ggplot()` don't natively intend to represent points true to size with `geom_point()`, as size aesthetic is optimized for visibility. Here we represent the same figure as above but with point size change based on tree DBH

```{r}
#| label: full-graph-dbh

tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point(aes(color = lc_code, size = tree_dbh)) + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0, slope = -1) + 
  geom_path(data= center_sq, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)", color = "LCS", size = "DBH (cm)")
```

Now if we want to see trees' DBH true to size, with the plot area, we can use `geom_circle()` from the package `ggforce`.

```{r}
#| label: full-graph-dbh-size

tree |> 
  filter(plot_no == 123, subplot_no == "B") |> 
  ggplot(aes(x = tree_x, y = tree_y)) + 
  geom_point(aes(fill = lc_code), shape = 21, size = 3, stroke = 0) + 
  geom_circle(aes(x0 = tree_x, y0 = tree_y, r = tree_dbh/200, fill = lc_code)) + 
  geom_path(data = circ16, aes(x = x, y = y)) + 
  geom_abline(intercept = 0, slope = 1) +
  geom_abline(intercept = 0, slope = -1) + 
  geom_path(data= center_sq, aes(x = x, y = y)) +
  coord_fixed() +
  labs(x = "X (m)", y = "Y (m)", fill = "LC code", size = "DBH (cm)")
```

Here we kept the points as the trees are small and wouldn't be visible otherwise.

<!-- MAIN SECTION BREAK -->

{{< pagebreak >}}

<!-- MAIN SECTION BREAK -->

# Session 07: tree weights and basal area

**Goals**

1.  Calculate tree weights for ratio estimators and for subplot per ha values

2.  Calculate tree basal area

<!-- Section 7.1 -->

## Tree weights for nested circles adjustment

<!-- Section 7.1.1 -->

### Tree weight for ratio estimator

In the context of **ratio estimator,** tree weight converts small size trees' variables to their equivalent if small trees were measured in the same area as the bigger sized trees.

For Lao PDR, the ratio between small and big trees is 4:

```{r}
#| label: weight_re

tree <- tree |> mutate(tree_weight = if_else(tree_dbh < 30, 4, 1))

```

Let's calculate where this value 4 comes from in @exr-71.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- Ex 7.1 -->

::: {#exr-71}
## \~ Where does weight 4 come from?

-   Calculate 'Asmall' as the area of a circle of 8m radius

-   Calculate 'Abig' as the area of a circle of 16m radius

-   Calculate Abig / Asmall
:::
::::

Type here answers to @exr-71:

```{r}
#| label: ex-71

## Solution
Asmall <- pi * 8^2 
Abig   <- pi * 16^2
Abig / Asmall 

```

<!-- Section 7.1.2 -->

### Tree weight for subplot per ha values

To get per ha at the subplot level, we first assign to each tree its subplot nested circle area, then the weight is the inverse of this area

```{r}
#| label: weight_sperr

tree <- tree |> 
  mutate( 
    tree_spha = if_else(tree_dbh < 30, pi * 16^2 / 10000, pi * 16^2 / 10000),
    tree_weight_spha = 1 / tree_spha
  )

```

There might be an error in the above code snippet, let's solve it in @exr-72.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 7.2 -->

::: {#exr-72}
## \~ Find the error  

-   Copy/paste the previous code snippet

-   Find and correct the error in `tree_spha`
:::
::::

Type here answers to @exr-72:

```{r}
#| label: ex-72

## !!! Solution
tree <- tree |> mutate( 
  tree_spha = if_else(tree_dbh < 30, pi * 8^2 / 10000, pi * 16^2 / 10000), 
  tree_weight_spha = 1 / tree_spha 
  )

```

<!-- Section 7.2 -->

### Calculate tree basal area

The basal area of a tree is its stem area footprint based on the measurement of it diameter at breast height.

```{r}
#| label: tree-ba

tree <- tree |> mutate(tree_ba = pi * (tree_dbh/200)^2)

```

Let's check subplot level basal area per land cover class in @exr-73.

:::: {.callout-warning appearance="simple" icon="false"}
<!-- EX 7.3 -->

::: {#exr-73}
## \~ (optional) Basal area per subplot  

-   From tree, use `group_by()` and `summarise()` to create `subplot_ba`, the sum of `tree_ba * tree_weight_spha` per plot and subplot number,

-   Join `lc_class_center` from the `subplot` table using suffix control,

-   Make a boxplot of `subplot_ba` against `lc_class_center`.
:::
::::

Type here answers to @exr-73:

```{r}
#| label: ex-73

## !!! Solutions
tmp_sp <- subplot |> select(plot_no, subplot_no, subplot_lc_class_center) 

tree |> 
  group_by(plot_no, subplot_no) |> 
  summarise(subplot_ba = sum(tree_ba * tree_weight_spha), .groups = "drop") |> 
  left_join(tmp_sp, by = join_by(plot_no, subplot_no)) |> 
  ggplot(aes(x = subplot_lc_class_center, y = subplot_ba)) + 
  geom_boxplot() + 
  geom_jitter(alpha = 0.1, shape = 21)

```

BONUS: The function `geom_jitter()` is a nice addition to boxplot figures to see all the subplot values on top of their distribution.
